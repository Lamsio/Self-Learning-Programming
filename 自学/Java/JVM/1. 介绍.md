## 介绍
Java程序之所以能够实现跨平台，本质就是因为他是运行在虚拟机上，而不同平台只需要安装对应平台的JVM即可运行（JRE中包含），所有的Java程序都采用统一的标准，在任何平台编译出来的字节码文件（.class）也是同样的，最后实际上是将编译后的字节码交由JVM进行处理执行。
![[Pasted image 20220306010820.png]]

正是得益于这种统一规范，除了Java以外，还有很多种JVM语言，例如Kotlin、Groovy等。他们语法虽与Java不同，但最终编译得到的字节码文件，和Java是相同规范的，同样可以交给JVM处理。
![[Pasted image 20220306011431.png]]

#### 构建第一个java汇编
现在我们在java中写一个类，例如
```java
public class main {  
    public int test(){  
         int a = 10;  
		 int b = 20;  
		 int c = a+b;  
		 return c;  
	}  
}
```

在写完这个简单的类后，我们可以点击构建去构建文件，然后使用`javap -v [构建文件的路径]`，可以获得该文件的java汇编指令，此时我们可以从打印的结果中找到如下内容：
```
  public int test();
    descriptor: ()I
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=4, args_size=1 //依次对应 所需使用的栈的深度、本地变量的数量、堆栈上最大对象数量（这里指的是this）
		  // 下面是所需执行的命令
         0: bipush        10 //0是程序的偏移地址，然后是指令，最后是操作数
         2: istore_1
         3: bipush        20
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: iload_3
        11: ireturn
      LineNumberTable:
        line 3: 0
        line 4: 3
        line 5: 6
        line 6: 10
		//局部变量表
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      12     0  this   Lmain;
            3       9     1     a   I
            6       6     2     b   I
           10       2     3     c   I
}

```

我们可以看到，java文件在编译后也会生成类似C语言那样的汇编指令，但这些指令是交给JVM执行的指令（虚拟机提供了一个类似物理机的运行环境，也有程序计数器之类的东西），最下方存放的是局部变量表，实际上`this`也在其中，所以我们才能在非静态方法中使用`this`关键字，在最上方标记了方法的返回值类型、访问权限等

介绍一下例子中的命令代表的含义：
- bipush 将单字节的常量值推到栈顶
- istore_1 将栈顶的int类型数值存入到第二个本地变量
- istore_2 将栈顶的int类型数值存入到第三个本地变量
- istore_3 将栈顶的int类型数值存入到第四个本地变量
- iload_1 将第二个本地变量推向栈顶
- iload_2 将第三个本地变量推向栈顶
- iload_3 将第四个本地变量推向栈顶
- iadd 将栈顶的两个int变量相加，并将结果压入栈顶
- ireturn 方法的返回操作

JVM运行字节码时，所有操作基本围绕了两种数据结构，一种是堆栈（本质是栈结构），还有一种是队列，如果JVM执行某条指令时，该指令需要对数据进行操作，那么被操作的数据在执行指令前，必须要压到堆栈上，JVM会自动将栈顶数据作为操作数。如果堆栈上的数据需要暂时保存起来时，它会被存储到局部变量队列上。

###### 流程说明
首先，程序会先执行`bipush`指令，将常量10压入栈顶。然后执行`istore_1`指令，将位于栈顶的数值（即刚压入的常量10）存入到第二个本地变量中（即局部变量表第二个变量，即为a），从而实现`int a = 10`的操作。第三第四条指令以此类推。

当程序执行到`iload_1`指令时，会将第二个本地变量推向栈顶（即a的值推入栈顶），再执行`iload_2`将第三个本地变量推向栈顶（即
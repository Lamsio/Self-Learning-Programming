## AOP
AOP 面向切面编程，旨在不影响源代码的情况下为源代码添加额外功能，类似于Python的函数装饰器

#### 准备工作
**依赖**
```xml
<dependencies>  
  <dependency>    
	  <groupId>org.springframework</groupId>  
	  <artifactId>spring-context</artifactId>  
      <version>5.3.20</version>  
  </dependency>  
  <dependency>    
	  <groupId>org.aspectj</groupId>  
      <artifactId>aspectjweaver</artifactId>  
      <version>1.9.9.1</version>  
  </dependency>
</dependencies>
```

**思想**
这是原本的功能类
```java
@Component  
public class BookDaoImpl implements BookDao {  
    @Override  
    public void save() {  
        System.out.println("tommy");  
    }  
  
    @Override  
    public void update() {  
        System.out.println("lucky");  
    }  
}
```
现在，我希望在使用update方法时，会额外输出一句"hello"

首先我们要在SpringConfig.java中加入注释`@EnableAspectJAutoProxy`，这句话用意是为了告知配置类我们配置了AOP，记得扫描一下。

然后另开一个新类用于配置AOP

```java
// MyAdvice.java
@Component  
@Aspect  
public class MyAdvice {  
  
    @Pointcut("execution(void com.itheima.dao.BookDao.update())")  
    private void pt(){}  
  
    @After("pt()")  
    public void method(){  
        System.out.println("hello work");  
    }  
}
```

说明一下，首先`@Aspect`是为了对应SpringConfig中`@EnableAspectJAutoProxy`，告知SpringConfig扫描时识别到这个类是AOP的。

`method()`方法是我们真正想实现的功能方法，上面的`@After("pt()")`是指该方法在pt方法运行后执行，但实际上pt方法只作为空壳而已，即使你写了内容在pt里也不会执行。`@Pointcut("execution(void com.itheima.dao.BookDao.update())")`是声明pt方法仅作为断点使用，当执行`void com.itheima.dao.BookDao.update()`方法后，会触发pt断点，从而实现了AOP功能

#### AOP工作流程
1. Spring容器启动
2. 读取所有切面配置中的切入点（读取使用的，未使用的不读取）
3. 初始化bean，判定bean对应的类中的方法是否有匹配到任何切入点
	- 匹配失败：创建对象
	- 匹配成功：创建原始对象的代理对象
4. 获取Bean执行方法
	- 获取Bean，调用方法并执行，完成操作
	- 获取的Bean是代理对象时，根据代理对象的运行模式运行原始方法与增强内容，完成操作
可能你对于上面这段流程比较困惑，以下是代码例子：

```java
public static void main(String[] args) {  
    ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class);  
    BookDao bd = ac.getBean(BookDao.class);  
    System.out.println(bd);  
}
```
```java
@Component  
@Aspect  
public class MyAdvice {  
  
    @Pointcut("execution(void com.itheima.dao.BookDao.update2())")// 注意是update2，实际没有这个方法  
    private void pt(){  
    }  
  
    @After("pt()")  
    public void method(){  
        System.out.println("hello work");  
    }  
}
```

我们只关注bd的实例类是什么，当打印bd时，结果是：
`com.itheima.dao.impl.BookDaoImpl@1f9f6368`
这看上去好像没啥区别，当你`System.out.println(bd.getClass());`打印时会发现，结果依旧是`class com.itheima.dao.impl.BookDaoImpl`，并没啥变化，这是因为在第三步时匹配失败了，并不存在`update2()`方法，因此创建对象。

但当你将`update2()`改回`update()`时（update方法是实际存在的），再次打印，结果发生了改变。
```
com.itheima.dao.impl.BookDaoImpl@1f9f6368
class jdk.proxy2.$Proxy19
```
你会发现，实际上创建的Proxy对象
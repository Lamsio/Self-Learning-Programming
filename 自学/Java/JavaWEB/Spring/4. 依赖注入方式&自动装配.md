## 依赖注入方式
![[Pasted image 20220611193259.png]]

#### setter注入
其实在先前的说明中，不难发现，所谓的依赖也能用于间接实现有参构造，我们可以通过`applicationContext.xml`中的`property`标签实现。 继续使用上节中的`applicationContext.xml`数据作为例子

```java
public class UserServiceImpl implements UserService{  
    UserDao ud;  
    public int age;  
    public String name;  
  
    public void setAge(int age) {  
        this.age = age;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public void setUd(UserDao ud) {  
        this.ud = ud;  
    }  
  
    @Override  
    public void save() {  
        System.out.println(this.name+this.age);  
    }  
}
```


```xml
<bean id="userServiceImpl" class="com.project.service.impl.UserServiceImpl">  
    <property name="ud" ref="userDaoImpl"/>  
    <property name="age" value="10"/>  
    <property name="name" value="LamKaKuan"/>  
</bean>
```

我们可以为`UserServiceImpl`类配置两个简单类型的变量，然后通过property标签填入值，你能看到引用类型用`ref`，简单类型用`value`

#### 构造器注入
说白了就是有参构造器而已，但不能像以往一样直接一个有参构造器就完事儿了，需要在配置文件中说明才行。

```java
public class UserServiceImpl implements UserService{  
    UserDao ud;  
  
    public UserServiceImpl(UserDao ud){  
        this.ud=ud;  
    }  
  
    @Override  
    public void save() {  
        System.out.println("hello");  
    }  
}
```

```xml
<bean id="userServiceImpl" class="com.project.service.impl.UserServiceImpl">  
    <constructor-arg name="ud" ref="userDaoImpl"/>  
</bean>
```

不难发现，其实和setter的区别就是多了个有参构造器以及内嵌了新的`constructor-arg`标签，name属性填写的是有参构造器中参数的名称，ref则是引用类型

**这种方式很明显违背了Spring的初衷（解耦合），当你更改参数名时也必须更改配置文件**

于是作者又更新了新属性

```xml
<bean id="userServiceImpl" class="com.project.service.impl.UserServiceImpl">  
    <constructor-arg index="0" ref="userDaoImpl"/>  
    <constructor-arg index="1" value="10"/>  
</bean>
```

为`constructor-arg`增加一个index作为识别顺序，从而解决耦合，但老实说这没卵用，我换了参数顺序你不就寄了吗

#### 选择
![[Pasted image 20220611195459.png]]

## 依赖自动装配
- IoC容器根据Bean所依赖的资源在容器中自动寻找并注入到Bean中的过程

使用自动装配时，总共两步
1. 需要被自动装配的变量必须已写有setter方法
2. bean标签中写有autowire=bytype

#### 选项
autowire有以下几个值可选：
1. byType - 根据类型去判断（同时多个候选则无法使用）
2. byName - 根据变量名判断

###### byType
```xml
<bean id="userDaoImpl" class="com.project.dao.impl.UserDaoImpl"/>  
<bean id="userDaoImpl2" class="com.project.dao.impl.UserDaoImpl"/>  
<bean id="userServiceImpl" class="com.project.service.impl.UserServiceImpl" autowire="byType"/>
```

```java
public class UserServiceImpl implements UserService{  
    UserDao userDao;  
  
  
    public void setUserDao(UserDao userDao) {  
        this.userDao = userDao;  
    }  
  
    @Override  
    public void save() {  
        System.out.println("hello");  
    }  
}
```

假设此时有两个userDao的实现类，对于UserServiceImpl而言就无法判断该装配哪一个了。

###### byName
虽然两个实现类很少见，但也并非不存在，真遇到这种问题该如何解决呢？
byName选项就是根据名字进行判断

```xml
<bean id="userDao" class="com.project.dao.impl.UserDaoImpl"/>  
<bean id="userDao2" class="com.project.dao.impl.UserDaoImpl"/>  
<bean id="userServiceImpl" class="com.project.service.impl.UserServiceImpl" autowire="byName"/>
```
```java
public class UserServiceImpl implements UserService{  
    UserDao userDao;  
  
  
    public void setUserDao(UserDao userDao) {  
        this.userDao = userDao;  
    }  
  
    @Override  
    public void save() {  
        System.out.println("hello");  
    }  
}
```
那么此时，就会自动装配id为`userDao`的。这个名字缘由是根据`setUserDao`函数去除`set`并将首字母小写得出的。
## 依赖注入方式
![[Pasted image 20220611193259.png]]

#### setter注入
其实在先前的说明中，不难发现，所谓的依赖也能用于间接实现有参构造，我们可以通过`applicationContext.xml`中的`property`标签实现。 继续使用上节中的`applicationContext.xml`数据作为例子

```java
public class UserServiceImpl implements UserService{  
    UserDao ud;  
    public int age;  
    public String name;  
  
    public void setAge(int age) {  
        this.age = age;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public void setUd(UserDao ud) {  
        this.ud = ud;  
    }  
  
    @Override  
    public void save() {  
        System.out.println(this.name+this.age);  
    }  
}
```


```xml
<bean id="userServiceImpl" class="com.project.service.impl.UserServiceImpl">  
    <property name="ud" ref="userDaoImpl"/>  
    <property name="age" value="10"/>  
    <property name="name" value="LamKaKuan"/>  
</bean>
```

我们可以为`UserServiceImpl`类配置两个简单类型的变量，然后通过property标签填入值，你能看到引用类型用`ref`，简单类型用`value`

#### 构造器注入
说白了就是有参构造器而已，但不能像以往一样直接一个有参构造器就完事儿了，需要在配置文件中说明才行。

```java
public class UserServiceImpl implements UserService{  
    UserDao ud;  
  
    public UserServiceImpl(UserDao ud){  
        this.ud=ud;  
    }  
  
    @Override  
    public void save() {  
        System.out.println("hello");  
    }  
}
```

```xml
<bean id="userServiceImpl" class="com.project.service.impl.UserServiceImpl">  
    <constructor-arg name="ud" ref="userDaoImpl"/>  
</bean>
```

不难发现，其实和setter的区别就是多了个有参构造器以及内嵌了新的`constructor-arg`标签，name属性填写的是有参构造器中参数的名称，ref则是引用类型

**这种方式很明显违背了Spring的初衷（解耦合），当你更改参数名时也必须更改配置文件**

于是作者又更新了新属性

```xml
<bean id="userServiceImpl" class="com.project.service.impl.UserServiceImpl">  
    <constructor-arg index="0" ref="userDaoImpl"/>  
    <constructor-arg index="1" value="10"/>  
</bean>
```

为`constructor-arg`增加一个index作为识别顺序，从而解决耦合，但老实说这没卵用，我换了参数顺序你不就寄了吗
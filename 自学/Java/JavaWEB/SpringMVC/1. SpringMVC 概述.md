## SpringMVC 概述
![[Pasted image 20220614164333.png]]

先前学习的MyBatis取代了原有的原生数据层，如今学习的SpringMVC取代了Servlet称为新的表示层

#### Servlet和SpringMVC对比
![[Pasted image 20220614164632.png]]
![[Pasted image 20220614164648.png]]
同一种功能，很明显SpringMVC的代码量更加少，这点能加快程序员开发进度

#### 依赖安装
```xml
<dependency>  
  <groupId>javax.servlet</groupId>  
  <artifactId>javax.servlet-api</artifactId>  
  <version>4.0.1</version>
  <scope>provided</scope>  
</dependency>  
<dependency>  
  <groupId>org.springframework</groupId>  
  <artifactId>spring-webmvc</artifactId>  
  <version>5.3.20</version>  
</dependency>
```

#### 主类配置
在Spring章节中，当我们打算获取bean时，我们往往需要先获得`AnnotationConfigApplicationContext`的实例对象，然后才能通过`getBean()`获取。
在实现该对象时，其实还有个与他类似的同胞类，就是专门用于web的`AnnotationConfigWebApplicationContext`，而我们SpringMVC就是要实例化这个类~

```java
public class SContainersInitConfig extends AbstractDispatcherServletInitializer {  
    @Override  
    protected WebApplicationContext createServletApplicationContext() {  
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();  
        ctx.register(SpringConfig.class);  
        return ctx;  
    }  
  
    @Override  
    protected String[] getServletMappings() {  
        return new String[]{"/"};  
    }  
  
    @Override  
    protected WebApplicationContext createRootApplicationContext() {  
        return null;  
    }  
}
```

从上面代码可知，我们需要让主类配置继承自`AbstractDispatcherServletInitializer`，该类有三个方法需要实现。
1. createServletApplicationContext
该方法用于创建Servlet容器时，加载SpringMVC对应的bean并放入`WebApplicationContext`对象范围中，而`WebApplicationContext`的作用范围为`ServletContext`范围，即整个web容器范围
## SpringMVC 概述
![[Pasted image 20220614164333.png]]

先前学习的MyBatis取代了原有的原生数据层，如今学习的SpringMVC取代了Servlet称为新的表示层

#### Servlet和SpringMVC对比
![[Pasted image 20220614164632.png]]
![[Pasted image 20220614164648.png]]
同一种功能，很明显SpringMVC的代码量更加少，这点能加快程序员开发进度

#### 依赖安装
```xml
<dependency>  
  <groupId>javax.servlet</groupId>  
  <artifactId>javax.servlet-api</artifactId>  
  <version>4.0.1</version>
  <scope>provided</scope>  
</dependency>  
<dependency>  
  <groupId>org.springframework</groupId>  
  <artifactId>spring-webmvc</artifactId>  
  <version>5.3.20</version>  
</dependency>
```

#### 主类配置
在Spring章节中，当我们打算获取bean时，我们往往需要先获得`AnnotationConfigApplicationContext`的实例对象，然后才能通过`getBean()`获取。
在实现该对象时，其实还有个与他类似的同胞类，就是专门用于web的`AnnotationConfigWebApplicationContext`，而我们SpringMVC就是要实例化这个类~

```java
public class SContainersInitConfig extends AbstractDispatcherServletInitializer {  
    @Override  
    protected WebApplicationContext createServletApplicationContext() {  
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();  
        ctx.register(SpringConfig.class);  
        return ctx;  
    }  
  
    @Override  
    protected String[] getServletMappings() {  
        return new String[]{"/"};  
    }  
  
    @Override  
    protected WebApplicationContext createRootApplicationContext() {  
        return null;  
    }  
}
```

从上面代码可知，我们需要让主类配置继承自`AbstractDispatcherServletInitializer`，该类有三个方法需要实现。
1. createServletApplicationContext
该方法用于创建Servlet容器时，加载SpringMVC对应的bean并放入`WebApplicationContext`对象范围中，而`WebApplicationContext`的作用范围为`ServletContext`范围，即整个web容器范围
![[Pasted image 20220615020916.png]]

2. getServletMappings
该方法用于设定SpringMVC对应的请求映射路径，设置为`/`标识拦截所有请求，人已请求都将转交给SpringMVC处理
![[Pasted image 20220615021016.png]]

3. createRootApplicationContext
如果创建Servlet容器时需要加载非SpringMVC的bean，则使用当前方法执行，使用方式同`createServletApplicationContext`

#### 启动流程
![[Pasted image 20220615021553.png]]

#### Bean加载
假设我们项目的目录如下
![[Pasted image 20220615021821.png]]

- SpringMVC仅加载
## 请求
在日常开发时，一个项目肯定不会是一个人完成的，往往需要一整个团队合力完成。
但配置请求路径时，你如何确保其他人配置的路径与你不冲突呢？

常见的方法就是
小明：负责user_info模块开发，因此所有路径必须是`/user/xxxx`
小红：负责eco模块开发，因此所有路径必须是`/eco/xxxx`

这的确能解决上述提到的问题。但倘若你的模块有三十几条路径，你每个方法都需要输入`/user`实在很麻烦，而且难保会不会某一个出差错。

有个很好的方法是:
```java

// 访问路径：http://localhost:8080/user/save
@Controller  
@RequestMapping("/user")  
public class UserController {  
  
    @RequestMapping("/save")  
    @ResponseBody  
    public String save(){  
        System.out.println("Loading save()...");  
        return "{'module':'springmvc'}";  
    }  
}
```

当你在class上设置`@RequestMapping`时，它就会认为这是路径前缀，这样一来，可以避免重复输入前缀，减少出错的情况。

###### 提醒
上面我们的路径耦合度很高，为了避免这种情况，还是建议使用properties解决，方法和Spring一样。

#### Get&Post参数接收
```java
@RequestMapping("/save")  
@ResponseBody  
public String save(String name){  
    System.out.println("Loading save()..."+name);  
    return "{'module':'springmvc'}";  
}
```

###### POST中文乱码
之前解决乱码问题时，我们是通过过滤器（Filter）实现的，但现在在SpringMVC中该如何做呢？

我们需要在主类配置中进行方法重新，我们的主类配置是继承自`AbstractAnnotationConfigDispatcherServletInitializer`，我们可以重写其`getServletFilters`方法

```java
public class SContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {

	@Override  
	protected Filter[] getServletFilters() {  
	    CharacterEncodingFilter filter = new CharacterEncodingFilter();  
	    filter.setEncoding("UTF-8");  
	    return new Filter[]{filter};  
	}
}
```

#### 参数名
前面的例子中
```java
@RequestMapping("/save")  
@ResponseBody  
public String save(String name){  
    System.out.println("Loading save()..."+name);  
    return "{'module':'springmvc'}";  
}
```

但如果参数名与前端提供的参数名
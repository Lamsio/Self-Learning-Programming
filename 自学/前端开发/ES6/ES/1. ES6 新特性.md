## ES介绍
ES，全名为ECMAScript，是脚本语言的规范，而平时经常编写的JavaScript就是ECMAScript的一种实现，所以ES新特性其实指的就是JavaScript特性。

#### 新特性？
1. 语法简洁，功能丰富
2. 框架开发应用

#### 前置知识
1. JavaScript 基本语法
2. AJAX 与 NodeJS

## ES6 新特性
ES6主要有以下几个新特性:
1. `let`关键字
#### let 关键字
在**ES5**中，我们只能用`var`定义变量，但在**ES6**中则多了两种定义变量的关键字，其中一个就是`let`

let关键字有以下特点:
1. 不可重复声明
```js
// let重复声明会报错
let a = 10;
let str = "你好";

// var重复声明不会报错
var b = 10;
var b = 12;
```

2. 块级作用域
```js
// 块级作用域： 函数，eval，if，else，while，for...
{
	let name = "tommy"
}

console.log(name); // name is not defined

{
	var user = "tommy"
}

console.log(user); // tommy
```

3. 不存在变量提升
```js
console.log(name); // 代码执行前先去收集所需的变量，被称为变量提升
var name = 'Tommy'; 

console.log(user); // user is not defined
let user = "Tommy";
```

#### const 关键字
拥有`let`的特性，此外，声明`const`变量时必须声明初始值（`let`可以不需要初始值），`const`变量一旦声明，其值就不能被修改，这点类似于`JAVA`中的`final`，但如果对于常量数组/对象的元素进行修改，不会报错。

- 潜规则: 常量命名都得完全大写

```js
const a = ["tommy","jack"];
a[0] = "kev"; // 允许修改
```

#### 解构赋值
解构赋值有以下几种:
1. 数组的解构
```js
const STUDENT = ["tommy","jack","kev","melissa"];
let {st_1,st_2,st_3,st_4} = STUDENT;
console.log(st_1);// tommy
console.log(st_2);// jack
console.log(st_3);// kev
console.log(st_4);// melissa
```

2. 对象的解构
```js
const HUMAN = {
	name: 'tommy',
	run: function(){
		console.log('我会跑步！');
	}
}

let {name,run} = HUMAN;
console.log(name); // tommy
console.log(run()); // 我会跑步！
```

```js
const STUDENT = ["tommy","jack","kev","melissa"];
const NEW_STUDENT = ["Hong","Thomas","Owen","Lognamm"];

STUDENT.push(...NEW_STUDENT);

console.log(STUDENT) //tommy,jack,kev,melissa,Hong,Thomas,Owen,Lognam
```

#### 模板字符串
ES6引入了模板字符串的概念，这是个极其有用的功能。

以往我们若想拼接字符串，总会用到`+`号

但在ES6里，我们可以通过以下方法快速实现字符串拼接

```js
const STUDENT = ["tommy","jack"];  
const NEW_STUDENT = ["Hong","Thomas"];  
  
console.log(`今年的学生名单: ${[STUDENT,NEW_STUDENT]}`) 
// 今年的学生名单: tommy,jack,Hong,Thomas
```

在这个例子中能发现两个新元素，第一个是反引号，这是用来表明这是一个模板字符串的，第二个是`${}`，包裹在这个符号中的元素会被视为javascript脚本执行，但不建议放入太过复杂的逻辑。

#### 简化对象属性写法
```js
let name = "tommy"
let run = function(){
	console.log("tommy会跑步")
}

// 这是ES6简写方法
let obj = {
	name,
	run
}

// 这是ES5原本的写法
let obj = {
	name: name,
	run: run
}
```

只要变量名与对象属性名一致，就能够省略后半部分。

#### 匿名函数
```js
// ES5的函数写法
let run = function(){
	console.log("tommy会跑步")
}

// ES6的函数写法
let run = ()=>{
	console.log("tommy会跑步")
}
```

以上两种写法是相等的，此外，匿名函数的特点是一次性，有时我们想临时调用某个函数，我们可以用匿名函数的方式满足这种需求。

但要留意的是，匿名函数的`this`有时并非与原版写法一致

```js
// 环境: 浏览器下
let run = function(){
	console.log(this.name)
}

let run2 = ()=>{
	console.log(this.name)
}

window.name = "tommy";
run(); //tommy
run2(); //tommy

const HUMAN = {
	name: 'jacky'
};

// call函数用来影响函数调用时的this指向
run.call(HUMAN); // jacky
run2.call(HUMAN); // tommy
```

上面例子可见，即使我们用`call`尝试改变run2的`this`指向，但其指向依旧是`window`，匿名函数的`this`是静态的，永远指向其声明时的作用域。

此外，匿名函数不能作为构造实例化对象，并且他没有`arguments`变量

```js
let run2 = (name)=>{  
    console.log(this.arguments)  //undefined
}  
run2("皮卡丘")
```
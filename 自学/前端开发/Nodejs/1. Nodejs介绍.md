## Nodejs介绍

#### 背景

近年来，浏览器给网站发送请求的过场一直没怎么变过。

当浏览器给网站发送请求，服务器接收到了请求然后开始检索请求的资源，并最终将结果返回给浏览器。

在传统的web服务器中(Apache)，每一个请求都会让服务器创建一个新的进程来处理这个请求。

后来有了Ajax后，我们不再需要通过刷新页面获取新数据，这对于社交性网站而言收益很大，可以即时更新好友的动态。但要实现该需求，我们需要让用户与服务器一直保持一个有效连接，最简单的方式就是通过长轮询(long polling)

HTTP请求不是持续性连接，请求一次，服务器响应一次，然后就会断开连接。长轮询则是模拟持续连接的方式，只要页面载入了，不管你需不需要服务器给你响应信息，浏览器都会间隔性地向服务器发送Ajax请求，从而实现保持通讯。

但长轮询的问题是极其占用服务器资源，就以Apache为例，每次都要单独开一个进程处理请求，若不及时关闭，可能会耗尽服务器资源进而瘫痪！

为解决以上情况，我们引入了**非阻塞**和**事件驱动**。

非阻塞即将服务器想象成一个loop循环，这个loop会一直运行，每当有个新请求，这个loop就接了这个请求，并把该请求传给其他进程（例如传给一个负责数据库查询的进程），然后响应一个回调。完事后，这个loop继续运行，接其他请求。

如果数据库把结果返回来了，loop就把结果返回给用户。在这种模式下，服务器的进程不会闲等着。从而在理论上说，同一时刻的数据库查询数量，以及用户的请求数量就没有限制了。服务器只在用户那边有事件发生的时候才响应，这就是**事件驱动**

除此之外还得提一句是“JavaScript仅支持单线程，因此不会发生锁的问题”

#### Node.js的两种机制
1.  非阻塞型I/O

JavaScript的一个特点是它只支持单线程，因此不需要担心会造成死锁的现象。 与客户端脚本语言不同的是，Node.js中为V8 JavaScript提供了非阻塞型I/O机制。 例如，在访问[数据库](https://cloud.tencent.com/solution/database?from=10680)取得搜索结果的时候，在开始访问数据库之后、数据库返回结果之前，存在一段时间的等待。 在传统的单线程处理机制中，在执行了访问数据库的代码之后，整个线程都将暂停下来，等待数据库返回查询结果之后才能继续执行其后面的代码。也就是I/O操作阻塞了代码的执行，极大的降低了程序的执行效率。 由于Node.js中采用了非阻塞型I/O机制，因此在执行访问数据库的代码之后将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中执行，从而提高了程序的执行效率。

2.  非阻塞型I/O

在Node.js中，在一个时刻只能执行一个事件回调函数，但是在执行一个事件回调函数的中途可以转而执行其他事件，然后返回继续执行原事件回调函数，这种处理机制叫事件环机制

#### Nodejs使用场景
当应用程序需要处理大量并发的输入/输出，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候

1.  聊天服务器

在一个人气很高的聊天应用程序中，在同一时刻通常可能存在大量用户与聊天服务器之间的并发连接，而服务器本身并不存在非常复杂的处理

2.  综合服务类网站 、电子商务网站的服务器 这类网站中，往往可能在每秒钟内接收到多达上千条数据并且需要将这些数据写到数据库中，如果使用其他的服务器（Apache或Tomcat），需要为每条数据的写入等待一段时间。而Node.js将通过其队列机制将这些数据迅速写到缓存区中，再通过每一个单独的处理从缓存中取出这些数据再写到数据库中，因为其使用的是非阻塞型的I/O机制，因此可以同时实现这些数据到数据库中的写入，而不必为每条数据等待一段时间